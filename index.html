<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shader Sphere</title>
  <style>
    body {
      margin: 0;
      background-color: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>

  <script>
    const canvas = document.getElementById("glcanvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");

    if (!gl) {
      alert("WebGL wird nicht unterst√ºtzt.");
    }

    const vsSource = `
      attribute vec3 position;
      attribute vec3 normal;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform float time;

      varying vec3 vColor;

      void main() {
        float len = length(position);
        float wave = sin(len * 10.0 - time * 2.0);
        vec3 displaced = position + normal * wave * 0.1;
        vColor = normalize(displaced) * 0.5 + 0.5;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vColor;
      void main() {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    const positionLoc = gl.getAttribLocation(program, "position");
    const normalLoc = gl.getAttribLocation(program, "normal");
    const projLoc = gl.getUniformLocation(program, "projectionMatrix");
    const mvLoc = gl.getUniformLocation(program, "modelViewMatrix");
    const timeLoc = gl.getUniformLocation(program, "time");

    // Sphere Geometry
    function createSphere(radius, latBands, lonBands) {
      const positions = [];
      const normals = [];
      const indices = [];

      for (let lat = 0; lat <= latBands; ++lat) {
        const theta = lat * Math.PI / latBands;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);

        for (let lon = 0; lon <= lonBands; ++lon) {
          const phi = lon * 2 * Math.PI / lonBands;
          const sinPhi = Math.sin(phi);
          const cosPhi = Math.cos(phi);

          const x = cosPhi * sinTheta;
          const y = cosTheta;
          const z = sinPhi * sinTheta;

          normals.push(x, y, z);
          positions.push(radius * x, radius * y, radius * z);
        }
      }

      for (let lat = 0; lat < latBands; ++lat) {
        for (let lon = 0; lon < lonBands; ++lon) {
          const first = lat * (lonBands + 1) + lon;
          const second = first + lonBands + 1;
          indices.push(first, second, first + 1);
          indices.push(second, second + 1, first + 1);
        }
      }

      return {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices),
      };
    }

    const sphere = createSphere(1, 40, 40);

    const posBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, sphere.positions, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, sphere.normals, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(normalLoc);
    gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW);

    function perspective(out, fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = (far + near) * nf;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[14] = (2 * far * near) * nf;
      out[15] = 0;
    }

    function identity(out) {
      for (let i = 0; i < 16; i++) out[i] = i % 5 == 0 ? 1 : 0;
    }

    function rotateY(out, a, rad) {
      const s = Math.sin(rad);
      const c = Math.cos(rad);
      identity(out);
      out[0] = c;
      out[2] = -s;
      out[8] = s;
      out[10] = c;
    }

    function translateZ(out, z) {
      identity(out);
      out[14] = z;
    }

    const projMatrix = new Float32Array(16);
    const mvMatrix = new Float32Array(16);

    function render(time) {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      perspective(projMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
      rotateY(mvMatrix, mvMatrix, time * 0.001);
      mvMatrix[14] = -3; // Move camera back

      gl.uniformMatrix4fv(projLoc, false, projMatrix);
      gl.uniformMatrix4fv(mvLoc, false, mvMatrix);
      gl.uniform1f(timeLoc, time * 0.001);

      gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
