<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shader Sphere - Standalone</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    // === Minimal THREE.js replacement (only necessary parts) ===
    class ShaderSphereApp {
      constructor() {
        this.init();
      }

      init() {
        // Create canvas and WebGL context
        this.canvas = document.createElement('canvas');
        document.body.appendChild(this.canvas);
        this.gl = this.canvas.getContext('webgl');

        // Resize
        window.addEventListener('resize', () => this.resize());
        this.resize();

        // Create shaders
        const vsSource = `
          precision mediump float;
          attribute vec3 position;
          attribute vec3 normal;

          uniform float time;
          uniform mat4 projectionMatrix;
          uniform mat4 modelViewMatrix;

          varying vec3 vColor;

          void main() {
            vec3 pos = position;
            float len = length(pos);
            float wave = sin(len * 10.0 - time * 2.0);
            vec3 displaced = pos + normal * wave * 0.1;

            vColor = normalize(displaced) * 0.5 + 0.5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
          }
        `;

        const fsSource = `
          precision mediump float;
          varying vec3 vColor;

          void main() {
            gl_FragColor = vec4(vColor, 1.0);
          }
        `;

        // Compile shaders
        const vertexShader = this.compileShader(vsSource, this.gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fsSource, this.gl.FRAGMENT_SHADER);

        // Create shader program
        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader);
        this.gl.attachShader(this.program, fragmentShader);
        this.gl.linkProgram(this.program);

        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
          console.error("Could not link shaders");
        }

        this.gl.useProgram(this.program);

        // Create geometry
        this.createSphere(1, 64, 64);
        this.animate();
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      }

      compileShader(source, type) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", this.gl.getShaderInfoLog(shader));
          return null;
        }

        return shader;
      }

      createSphere(radius, latBands, longBands) {
        const positions = [];
        const normals = [];
        const indices = [];

        for (let lat = 0; lat <= latBands; lat++) {
          const theta = lat * Math.PI / latBands;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);

          for (let lon = 0; lon <= longBands; lon++) {
            const phi = lon * 2 * Math.PI / longBands;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);

            const x = cosPhi * sinTheta;
            const y = cosTheta;
            const z = sinPhi * sinTheta;

            normals.push(x, y, z);
            positions.push(radius * x, radius * y, radius * z);
          }
        }

        for (let lat = 0; lat < latBands; lat++) {
          for (let lon = 0; lon < longBands; lon++) {
            const first = (lat * (longBands + 1)) + lon;
            const second = first + longBands + 1;
            indices.push(first, second, first + 1);
            indices.push(second, second + 1, first + 1);
          }
        }

        const gl = this.gl;

        this.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(this.program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

        this.normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        const normalLocation = gl.getAttribLocation(this.program, 'normal');
        gl.enableVertexAttribArray(normalLocation);
        gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);

        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        this.indexCount = indices.length;
      }

      animate() {
        const gl = this.gl;
        const projMatrix = mat4.create();
        const mvMatrix = mat4.create();

        const timeUniform = gl.getUniformLocation(this.program, "time");
        const projUniform = gl.getUniformLocation(this.program, "projectionMatrix");
        const mvUniform = gl.getUniformLocation(this.program, "modelViewMatrix");

        const render = (t) => {
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.enable(gl.DEPTH_TEST);

          const aspect = this.canvas.width / this.canvas.height;
          mat4.perspective(projMatrix, Math.PI / 4, aspect, 0.1, 100.0);
          mat4.identity(mvMatrix);
          mat4.translate(mvMatrix, mvMatrix, [0, 0, -3]);
          mat4.rotateY(mvMatrix, mvMatrix, t * 0.001);

          gl.uniformMatrix4fv(projUniform, false, projMatrix);
          gl.uniformMatrix4fv(mvUniform, false, mvMatrix);
          gl.uniform1f(timeUniform, t * 0.001);

          gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
          requestAnimationFrame(render);
        };

        requestAnimationFrame(render);
      }
    }

    // === Minimal mat4 implementation ===
    const mat4 = {
      create: () => new Float32Array(16).fill(0).map((v, i) => (i % 5 === 0 ? 1 : 0)),
      identity: (out) => {
        for (let i = 0; i < 16; i++) out[i] = i % 5 === 0 ? 1 : 0;
        return out;
      },
      translate: (out, a, v) => {
        mat4.identity(out);
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        return out;
      },
      rotateY: (out, a, rad) => {
        const s = Math.sin(rad);
        const c = Math.cos(rad);
        mat4.identity(out);
        out[0] = c;
        out[2] = -s;
        out[8] = s;
        out[10] = c;
        return out;
      },
      perspective: (out, fovy, aspect, near, far) => {
        const f = 1.0 / Math.tan(fovy / 2);
        const nf = 1 / (near - far);
        out[0] = f / aspect;
        out[5] = f;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[14] = (2 * far * near) * nf;
        out[1] = out[2] = out[3] = out[4] = out[6] = out[7] = out[8] = out[9] = out[12] = out[13] = out[15] = 0;
        return out;
      }
    };

    // Start app
    new ShaderSphereApp();
  </script>
</body>
</html>
